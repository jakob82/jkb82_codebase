let fs = require('fs');

let range = 0; let textblock;

function hashingProceduralScriptGeneration() {
    
    for (let i1 = 0; i1 < 2000; i1++) {
        
        range++; let webGLscriptName = ["WEBGL" + range + ".html"];
        
        console.log(webGLscriptName, "utf-8");
        
		let textblock="<!DOCTYPE html>"
		+	" \n<html lang='en' >"
		+	" \n<head>"
		+	" \n  <meta charset='UTF-8'>"
		+	" \n  <title>CodePen - Rain</title>"
		+	" \n  <meta name='viewport' content='width=device-width, initial-scale=1'><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css'>"
		+	" \n<link rel='stylesheet' href='./style.css'>"
		+	" \n"
		+	" \n</head>"
		+	" \n<body>"
		+	" \n<!-- partial:index.partial.html -->"
		+	" \n<div id='instructions'></div>"
		+	" \n<canvas id='canvas'>Canvas is not supported in your browser</canvas>"
		+	" \n<!-- partial -->"
		+	" \n  <style>tml, body, canvas, #instructions {"
		+	" \n  position: absolute;"
		+	" \n  width: 100%;"
		+	" \n  height: 100%;"
		+	" \n}"
		+	" \n"
		+	" \nbody {"
		+	" \n  /* FF3.6-15 */"
		+	" \n  /* Chrome10-25,Safari5.1-6 */"
		+	" \n  background: -webkit-gradient(linear, left top, left bottom, from(#080d28), to(#261300));"
		+	" \n  background: linear-gradient(to bottom, #080d28 0%, #261300 100%);"
		+	" \n  /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */"
		+	" \n}"
		+	" \n"
		+	" \n#instructions {"
		+	" \n  opacity: 1;"
		+	" \n  -webkit-transition: opacity 2s;"
		+	" \n  transition: opacity 2s;"
		+	" \n  background-repeat: no-repeat;"
		+	" \n  background-position: center center;"
		+	" \n  background-size: contain;"
		+	" \n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjI1NnB4IiBoZWlnaHQ9IjI1NnB4IiB2aWV3Qm94PSIwIDAgMjU2IDI1NiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjU2IDI1NjsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxwb2x5Z29uIHN0eWxlPSJmaWxsOiNGRkZGRkY7IiBwb2ludHM9IjIyLjE0LDQ4IDM3LjA0NSwyMi4xODMgNTEuOTUxLDQ4Ii8+PHBvbHlnb24gc3R5bGU9ImZpbGw6I0ZGRkZGRjsiIHBvaW50cz0iNTEuOTUxLDE4NiAzNy4wNDUsMjExLjgxNiAyMi4xNCwxODYiLz48cG9seWdvbiBzdHlsZT0iZmlsbDojRkZGRkZGOyIgcG9pbnRzPSI3MCwyMzMuODEyIDQ0LjE4NCwyMTguOTA2IDcwLDIwNC4wMDEiLz48cG9seWdvbiBzdHlsZT0iZmlsbDojRkZGRkZGOyIgcG9pbnRzPSIyMDgsMjA0LjAwMSAyMzMuODE2LDIxOC45MDYgMjA4LDIzMy44MTIiLz48cmVjdCB4PSIzMSIgeT0iNDciIHN0eWxlPSJmaWxsOiNGRkZGRkY7IiB3aWR0aD0iMTIiIGhlaWdodD0iMTQxIi8+PHJlY3QgeD0iNjgiIHk9IjIxMyIgc3R5bGU9ImZpbGw6I0ZGRkZGRjsiIHdpZHRoPSIxNDEiIGhlaWdodD0iMTIiLz48dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDExNC45NDUzIDEwMy4zNTc5KSI+PHRzcGFuIHg9IjAiIHk9IjAiIHN0eWxlPSJmaWxsOiNGRkZGRkY7IGZvbnQtZmFtaWx5OidBcmlhbC1Cb2xkTVQnOyBmb250LXNpemU6MTY7Ij5EUkFHPC90c3Bhbj48dHNwYW4geD0iMTYuMDA0IiB5PSIxOS4yIiBzdHlsZT0iZmlsbDojRkZGRkZGOyBmb250LWZhbWlseTonQXJpYWwtQm9sZE1UJzsgZm9udC1zaXplOjE2OyI+dG88L3RzcGFuPjx0c3BhbiB4PSItMTEuMTEzIiB5PSIzOC40MDEiIHN0eWxlPSJmaWxsOiNGRkZGRkY7IGZvbnQtZmFtaWx5OidBcmlhbC1Cb2xkTVQnOyBmb250LXNpemU6MTY7Ij5DSEFOR0U8L3RzcGFuPjwvdGV4dD48dGV4dCB0cmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDExNy4xNzE5IDIwNy4xMzI4KSIgc3R5bGU9ImZpbGw6I0ZGRkZGRjsgZm9udC1mYW1pbHk6J0FyaWFsLUJvbGRNVCc7IGZvbnQtc2l6ZToxNjsiPldJTkQ8L3RleHQ+PHRleHQgdHJhbnNmb3JtPSJtYXRyaXgoLTQuMzcxMTM5ZS0wOCAtMSAxIC00LjM3MTEzOWUtMDggNTkuODcwMSAxODEuMDU4NikiIHN0eWxlPSJmaWxsOiNGRkZGRkY7IGZvbnQtZmFtaWx5OidBcmlhbC1Cb2xkTVQnOyBmb250LXNpemU6MTY7Ij5SQUlOIElOVEVOU0lUWTwvdGV4dD48L3N2Zz4=);"
		+	" \n}"
		+	" \n@media (max-height: 400px) {"
		+	" \n  #instructions {"
		+	" \n	display: none;"
		+	" \n  }"
		+	" \n}"
		+	" \n</style>"
		+	" \n<script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js'></script><script  src='./script.js'></script>"
		+	" \n"
		+	" \n"
		+	" \n"
		+	" \n"
		+	" \n  <script>"
		+	" \n	// Falling rain simulation using 2D canvas"
		+	" \n// - vanilla JS, no frameworks"
		+	" \n// - framerate independent physics"
		+	" \n// - slow-mo / fast-forward support via demo.speed"
		+	" \n// - supports high-DPI screens"
		+	" \n// - falling rain particles are drawn as vector lines"
		+	" \n// - splash particles are lazily pre-rendered so gradients aren't computed each frame"
		+	" \n// - all particles make use of object pooling to further boost performance"
		+	" \n"
		+	" \n// initialize"
		+	" \ndocument.addEventListener('DOMContentLoaded', function() {"
		+	" \n	demo.init();"
		+	" \n	window.addEventListener('resize', demo.resize);"
		+	" \n});"
		+	" \n"
		+	" \n// demo namespace"
		+	" \nvar demo = {"
		+	" \n	// CUSTOMIZABLE PROPERTIES"
		+	" \n	// - physics speed multiplier: allows slowing down or speeding up simulation"
		+	" \n	speed: 1,"
		+	" \n	// - color of particles"
		+	" \n	color: {"
		+	" \n		r: '80',"
		+	" \n		g: '175',"
		+	" \n		b: '255',"
		+	" \n		a: '0.5'"
		+	" \n	},"
		+	" \n	"
		+	" \n	// END CUSTOMIZATION"
		+	" \n	// whether demo is running"
		+	" \n	started: false,"
		+	" \n	// canvas and associated context references"
		+	" \n	canvas: null,"
		+	" \n	ctx: null,"
		+	" \n	// viewport dimensions (DIPs)"
		+	" \n	width: 0,"
		+	" \n	height: 0,"
		+	" \n	// devicePixelRatio alias (should only be used for rendering, physics shouldn't care)"
		+	" \n	dpr: window.devicePixelRatio || 1,"
		+	" \n	// time since last drop"
		+	" \n	drop_time: 0,"
		+	" \n	// ideal time between drops (changed with mouse/finger)"
		+	" \n	drop_delay: 25,"
		+	" \n	// wind applied to rain (changed with mouse/finger)"
		+	" \n	wind: 4,"
		+	" \n	// color of rain (set in init)"
		+	" \n	rain_color: null,"
		+	" \n	rain_color_clear: null,"
		+	" \n	// rain particles"
		+	" \n	rain: [],"
		+	" \n	rain_pool: [],"
		+	" \n	// rain droplet (splash) particles"
		+	" \n	drops: [],"
		+	" \n	drop_pool: []"
		+	" \n};"
		+	" \n"
		+	" \n// demo initialization (should only run once)"
		+	" \ndemo.init = function() {"
		+	" \n	if (!demo.started) {"
		+	" \n		demo.started = true;"
		+	" \n		demo.canvas = document.getElementById('canvas');"
		+	" \n		demo.ctx = demo.canvas.getContext('2d');"
		+	" \n		var c = demo.color;"
		+	" \n		demo.rain_color = 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + c.a + ')';"
		+	" \n		demo.rain_color_clear = 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',0)';"
		+	" \n		demo.resize();"
		+	" \n		Ticker.addListener(demo.step);"
		+	" \n		"
		+	" \n		// "
		+	" \n		const gui = new dat.GUI();"
		+	" \n		gui.add(demo, 'speed', 0.2, 2);"
		+	" \n		"
		+	" \n		// fade out instructions after a few seconds"
		+	" \n		var instructions = document.getElementById('instructions');"
		+	" \n		setTimeout(function() {"
		+	" \n			instructions.style.opacity = 0;"
		+	" \n			setTimeout(function(){"
		+	" \n				instructions.parentNode.removeChild(instructions);"
		+	" \n			}, 2000);"
		+	" \n		}, 4000);"
		+	" \n	}"
		+	" \n}"
		+	" \n"
		+	" \n// (re)size canvas (clears all particles)"
		+	" \ndemo.resize = function() {"
		+	" \n	// localize common references"
		+	" \n	var rain = demo.rain;"
		+	" \n	var drops = demo.drops;"
		+	" \n	// recycle particles"
		+	" \n	for (var i = rain.length - 1; i >= 0; i--) {"
		+	" \n			rain.pop().recycle();"
		+	" \n	}"
		+	" \n	for (var i = drops.length - 1; i >= 0; i--) {"
		+	" \n			drops.pop().recycle();"
		+	" \n	}"
		+	" \n	// resize"
		+	" \n	demo.width = window.innerWidth;"
		+	" \n	demo.height = window.innerHeight;"
		+	" \n	demo.canvas.width = demo.width * demo.dpr;"
		+	" \n	demo.canvas.height = demo.height * demo.dpr;"
		+	" \n}"
		+	" \n"
		+	" \ndemo.step = function(time, lag) {"
		+	" \n	// localize common references"
		+	" \n	var demo = window.demo;"
		+	" \n	var speed = demo.speed;"
		+	" \n	var width = demo.width;"
		+	" \n	var height = demo.height;"
		+	" \n	var wind = demo.wind;"
		+	" \n	var rain = demo.rain;"
		+	" \n	var rain_pool = demo.rain_pool;"
		+	" \n	var drops = demo.drops;"
		+	" \n	var drop_pool = demo.drop_pool;"
		+	" \n	"
		+	" \n	// multiplier for physics"
		+	" \n	var multiplier = speed * lag;"
		+	" \n	"
		+	" \n	// spawn drops"
		+	" \n	demo.drop_time += time * speed;"
		+	" \n	while (demo.drop_time > demo.drop_delay) {"
		+	" \n		demo.drop_time -= demo.drop_delay;"
		+	" \n		var new_rain = rain_pool.pop() || new Rain();"
		+	" \n		new_rain.init();"
		+	" \n		var wind_expand = Math.abs(height / new_rain.speed * wind); // expand spawn width as wind increases"
		+	" \n		var spawn_x = Math.random() * (width + wind_expand);"
		+	" \n		if (wind > 0) spawn_x -= wind_expand;"
		+	" \n		new_rain.x = spawn_x;"
		+	" \n		rain.push(new_rain);"
		+	" \n	}"
		+	" \n	"
		+	" \n	// rain physics"
		+	" \n	for (var i = rain.length - 1; i >= 0; i--) {"
		+	" \n		var r = rain[i];"
		+	" \n		r.y += r.speed * r.z * multiplier;"
		+	" \n		r.x += r.z * wind * multiplier;"
		+	" \n		// remove rain when out of view"
		+	" \n		if (r.y > height) {"
		+	" \n			// if rain reached bottom of view, show a splash"
		+	" \n			r.splash();"
		+	" \n		}"
		+	" \n		// recycle rain"
		+	" \n		if (r.y > height + Rain.height * r.z || (wind < 0 && r.x < wind) || (wind > 0 && r.x > width + wind)) {"
		+	" \n			r.recycle();"
		+	" \n			rain.splice(i, 1);"
		+	" \n		}"
		+	" \n	}"
		+	" \n	"
		+	" \n	// splash drop physics"
		+	" \n	var drop_max_speed = Drop.max_speed;"
		+	" \n	for (var i = drops.length - 1; i >= 0; i--) {"
		+	" \n		var d = drops[i];"
		+	" \n		d.x += d.speed_x * multiplier;"
		+	" \n		d.y += d.speed_y * multiplier;"
		+	" \n		// apply gravity - magic number 0.3 represents a faked gravity constant"
		+	" \n		d.speed_y += 0.3 * multiplier;"
		+	" \n		// apply wind (but scale back the force)"
		+	" \n		d.speed_x += wind / 25 * multiplier;"
		+	" \n		if (d.speed_x < -drop_max_speed) {"
		+	" \n			d.speed_x = -drop_max_speed;"
		+	" \n		}else if (d.speed_x > drop_max_speed) {"
		+	" \n			d.speed_x = drop_max_speed;"
		+	" \n		}"
		+	" \n		// recycle"
		+	" \n		if (d.y > height + d.radius) {"
		+	" \n			d.recycle();"
		+	" \n			drops.splice(i, 1);"
		+	" \n		}"
		+	" \n	}"
		+	" \n	"
		+	" \n	demo.draw();"
		+	" \n}"
		+	" \n"
		+	" \ndemo.draw = function() {"
		+	" \n	// localize common references"
		+	" \n	var demo = window.demo;"
		+	" \n	var width = demo.width;"
		+	" \n	var height = demo.height;"
		+	" \n	var dpr = demo.dpr;"
		+	" \n	var rain = demo.rain;"
		+	" \n	var drops = demo.drops;"
		+	" \n	var ctx = demo.ctx;"
		+	" \n	"
		+	" \n	// start fresh"
		+	" \n	ctx.clearRect(0, 0, width*dpr, height*dpr);"
		+	" \n	"
		+	" \n	// draw rain (trace all paths first, then stroke once)"
		+	" \n	ctx.beginPath();"
		+	" \n	var rain_height = Rain.height * dpr;"
		+	" \n	for (var i = rain.length - 1; i >= 0; i--) {"
		+	" \n		var r = rain[i];"
		+	" \n		var real_x = r.x * dpr;"
		+	" \n		var real_y = r.y * dpr;"
		+	" \n		ctx.moveTo(real_x, real_y);"
		+	" \n		// magic number 1.5 compensates for lack of trig in drawing angled rain"
		+	" \n		ctx.lineTo(real_x - demo.wind * r.z * dpr * 1.5, real_y - rain_height * r.z);"
		+	" \n	}"
		+	" \n	ctx.lineWidth = Rain.width * dpr;"
		+	" \n	ctx.strokeStyle = demo.rain_color;"
		+	" \n	ctx.stroke();"
		+	" \n	"
		+	" \n	// draw splash drops (just copy pre-rendered canvas)"
		+	" \n	for (var i = drops.length - 1; i >= 0; i--) {"
		+	" \n		var d = drops[i];"
		+	" \n		var real_x = d.x * dpr - d.radius;"
		+	" \n		var real_y = d.y * dpr - d.radius;"
		+	" \n		ctx.drawImage(d.canvas, real_x, real_y);"
		+	" \n	}"
		+	" \n}"
		+	" \n"
		+	" \n"
		+	" \n// Rain definition"
		+	" \nfunction Rain() {"
		+	" \n	this.x = 0;"
		+	" \n	this.y = 0;"
		+	" \n	this.z = 0;"
		+	" \n	this.speed = 25;"
		+	" \n	this.splashed = false;"
		+	" \n}"
		+	" \nRain.width = 2;"
		+	" \nRain.height = 40;"
		+	" \nRain.prototype.init = function() {"
		+	" \n	this.y = Math.random() * -100;"
		+	" \n	this.z = Math.random() * 0.5 + 0.5;"
		+	" \n	this.splashed = false;"
		+	" \n}"
		+	" \nRain.prototype.recycle = function() {"
		+	" \n	demo.rain_pool.push(this);"
		+	" \n}"
		+	" \n// recycle rain particle and create a burst of droplets"
		+	" \nRain.prototype.splash = function() {"
		+	" \n	if (!this.splashed) {"
		+	" \n		this.splashed = true;"
		+	" \n		var drops = demo.drops;"
		+	" \n		var drop_pool = demo.drop_pool;"
		+	" \n"
		+	" \n		for (var i=0; i<16; i++) {"
		+	" \n			var drop = drop_pool.pop() || new Drop();"
		+	" \n			drops.push(drop);"
		+	" \n			drop.init(this.x);"
		+	" \n		}"
		+	" \n	}"
		+	" \n}"
		+	" \n"
		+	" \n"
		+	" \n// Droplet definition"
		+	" \nfunction Drop() {"
		+	" \n	this.x = 0;"
		+	" \n	this.y = 0;"
		+	" \n	this.radius = Math.round(Math.random() * 2 + 1) * demo.dpr;"
		+	" \n	this.speed_x = 0;"
		+	" \n	this.speed_y = 0;"
		+	" \n	this.canvas = document.createElement('canvas');"
		+	" \n	this.ctx = this.canvas.getContext('2d');"
		+	" \n	"
		+	" \n	// render once and cache"
		+	" \n	var diameter = this.radius * 2;"
		+	" \n	this.canvas.width = diameter;"
		+	" \n	this.canvas.height = diameter;"
		+	" \n"
		+	" \n	var grd = this.ctx.createRadialGradient(this.radius, this.radius , 1, this.radius, this.radius, this.radius);"
		+	" \n	grd.addColorStop(0, demo.rain_color);"
		+	" \n	grd.addColorStop(1, demo.rain_color_clear);"
		+	" \n	this.ctx.fillStyle = grd;"
		+	" \n	this.ctx.fillRect(0, 0, diameter, diameter);"
		+	" \n}"
		+	" \n"
		+	" \nDrop.max_speed = 5;"
		+	" \n"
		+	" \nDrop.prototype.init = function(x) {"
		+	" \n	this.x = x;"
		+	" \n	this.y = demo.height;"
		+	" \n	var angle = Math.random() * Math.PI - (Math.PI * 0.5);"
		+	" \n	var speed = Math.random() * Drop.max_speed;"
		+	" \n	this.speed_x = Math.sin(angle) * speed;"
		+	" \n	this.speed_y = -Math.cos(angle) * speed;"
		+	" \n}"
		+	" \nDrop.prototype.recycle = function() {"
		+	" \n	demo.drop_pool.push(this);"
		+	" \n}"
		+	" \n"
		+	" \n"
		+	" \n"
		+	" \n"
		+	" \n// handle interaction"
		+	" \ndemo.mouseHandler = function(evt) {"
		+	" \n	demo.updateCursor(evt.clientX, evt.clientY);"
		+	" \n}"
		+	" \ndemo.touchHandler = function(evt) {"
		+	" \n	evt.preventDefault();"
		+	" \n	var touch = evt.touches[0];"
		+	" \n	demo.updateCursor(touch.clientX, touch.clientY);"
		+	" \n}"
		+	" \ndemo.updateCursor = function(x, y) {"
		+	" \n	x /= demo.width;"
		+	" \n	y /= demo.height;"
		+	" \n	var y_inverse = (1 - y);"
		+	" \n	"
		+	" \n	demo.drop_delay = y_inverse*y_inverse*y_inverse * 100 + 2;"
		+	" \n	demo.wind = (x - 0.5) * 50;"
		+	" \n}"
		+	" \n"
		+	" \ndocument.addEventListener('mousemove', demo.mouseHandler);"
		+	" \ndocument.addEventListener('touchstart', demo.touchHandler);"
		+	" \ndocument.addEventListener('touchmove', demo.touchHandler);"
		+	" \n"
		+	" \n"
		+	" \n"
		+	" \n// Frame ticker helper module"
		+	" \nvar Ticker = (function(){"
		+	" \n	var PUBLIC_API = {};"
		+	" \n"
		+	" \n	// public"
		+	" \n	// will call function reference repeatedly once registered, passing elapsed time and a lag multiplier as parameters"
		+	" \n	PUBLIC_API.addListener = function addListener(fn) {"
		+	" \n		if (typeof fn !== 'function') throw('Ticker.addListener() requires a function reference passed in.');"
		+	" \n"
		+	" \n		listeners.push(fn);"
		+	" \n"
		+	" \n		// start frame-loop lazily"
		+	" \n		if (!started) {"
		+	" \n			started = true;"
		+	" \n			queueFrame();"
		+	" \n		}"
		+	" \n	};"
		+	" \n"
		+	" \n	// private"
		+	" \n	var started = false;"
		+	" \n	var last_timestamp = 0;"
		+	" \n	var listeners = [];"
		+	" \n	// queue up a new frame (calls frameHandler)"
		+	" \n	function queueFrame() {"
		+	" \n		if (window.requestAnimationFrame) {"
		+	" \n			requestAnimationFrame(frameHandler);"
		+	" \n		} else {"
		+	" \n			webkitRequestAnimationFrame(frameHandler);"
		+	" \n		}"
		+	" \n	}"
		+	" \n	function frameHandler(timestamp) {"
		+	" \n		var frame_time = timestamp - last_timestamp;"
		+	" \n		last_timestamp = timestamp;"
		+	" \n		// make sure negative time isn't reported (first frame can be whacky)"
		+	" \n		if (frame_time < 0) {"
		+	" \n			frame_time = 17;"
		+	" \n		}"
		+	" \n		// - cap minimum framerate to 15fps[~68ms] (assuming 60fps[~17ms] as 'normal')"
		+	" \n		else if (frame_time > 68) {"
		+	" \n			frame_time = 68;"
		+	" \n		}"
		+	" \n"
		+	" \n		// fire custom listeners"
		+	" \n		for (var i = 0, len = listeners.length; i < len; i++) {"
		+	" \n			listeners[i].call(window, frame_time, frame_time / 16.67);"
		+	" \n		}"
		+	" \n		"
		+	" \n		// always queue another frame"
		+	" \n		queueFrame();"
		+	" \n	}"
		+	" \n"
		+	" \n	return PUBLIC_API;"
		+	" \n}());"
		+	" \n </script>"
		+	" \n "
		+	" \n </body>"
		+	" \n </html>";

		fs.writeFileSync("./WEBGL/" + webGLscriptName, textblock);
         
    }
    
    return 0;
    
}

hashingProceduralScriptGeneration();