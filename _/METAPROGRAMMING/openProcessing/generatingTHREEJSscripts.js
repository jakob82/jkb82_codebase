let fs = require('fs');

const colors = [255, 255*0.5, 255*0.25, 255*0.125, 0];
const resolution = [2054, 2054 * 0.5, 2054 * 0.25, 2054 * 0.125, 2054 * 0.5 * 0.1, 2054 * 0.25 * 0.1, 2054 * 0.125 * 0.1];

let smallNumbers; for(let i=0; i<colors.length; i++) {smallNumbers.append(colors[i] * 0.01); console.log(smallNumbers[i]);}

const midRangeSmallNumbers = [255 * 0.25, 255 * 0.5  * 0.25, 255 * 0.25 * 0.25, 255 * 0.125 * 0.25, 0];

let iterationArray = [0, 0]; let range = 0;

let permutationIndexA = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
let permutationIndexB = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
let permutationIndexC = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
let permutationIndexD = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

let textBlock = ["int num,cnt,px,py; Particle[] particles; boolean initialised=false,doClear=false; float lastRelease=-1; void setup() { size(" + permutationIndexB[0] + ", " + permutationIndexB[1] + "); background(" + permutationIndexB[2] + "); smooth(); rectMode(CENTER_DIAMETER); ellipseMode(CENTER_DIAMETER); cnt=0; num=" + permutationIndexB[3] + "; particles=new Particle[num]; for(int i=0; i<num; i++) particles[i]=new Particle(); px=-1; py=-1;} void draw() { if(doClear) { background(" + permutationIndexB[4] + "); doClear=false; } if(!initialised) { stroke(0); noFill(); pushMatrix(); strokeWeight(" + permutationIndexD[0] + "); translate(width/" + permutationIndexD[1] + "-" + permutationIndexC[0] + ",height/" + permutationIndexD[2] + "-" + permutationIndexD[3] + "); scale(" + permutationIndexD[4] + "," + permutationIndexD[5] + "); beginShape(); vertex(" + permutationIndexD[6] + ",0); vertex(0,0); vertex(0," + permutationIndexD[7] + "); vertex(" + permutationIndexD[8] + "," + permutationIndexD[9] + "); endShape(); beginShape(); vertex(" + permutationIndexD[10] + ",-" + permutationIndexD[11] + "); vertex(" + permutationIndexD[12] + "," + permutationIndexD[13] + "); endShape(); line(" + permutationIndexD[14] + ",-" + permutationIndexD[15] + "," + permutationIndexD[16] + ",-" + permutationIndexD[17] + "); beginShape(); vertex(" + permutationIndexD[18] + ",0); vertex(" + permutationIndexD[19] + ", " + permutationIndexD[0] + "); endShape(); beginShape(); vertex(" + permutationIndexD[1] + ",0); vertex(" + permutationIndexD[2] + ",0); vertex(" + permutationIndexD[3] + ", " + permutationIndexD[4] + "); vertex(" + + permutationIndexD[4] + + ", " + permutationIndexD[5] + "); endShape(); line(" + permutationIndexD[6] + ", " + permutationIndexD[7] + ", "  + permutationIndexD[8] +  ", " + + permutationIndexD[9] + + "); line(" + + permutationIndexD[10] + + "," + + permutationIndexD[11] + ", " + permutationIndexD[12] + ", " + permutationIndexD[13] + "); line(" + permutationIndexD[12] + ", " + permutationIndexD[13] + ", " + permutationIndexD[14] + " ,-" + permutationIndexD[15] + "); line(" + permutationIndexD[15] + ", + " + permutationIndexD[16] + ", " + permutationIndexD[17] + ", " + permutationIndexD[18] + "); popMatrix();} noStroke(); if(mousePressed) { int partNum,i; float dir; if(px==-1) { px=mouseX; py=mouseY; dir=0;} else if(px==mouseX && py==mouseY) dir=int(random(" + permutationIndexD[0] + "))*" + permutationIndexD[1] + "; else dir=degrees(atan2(mouseY-py,mouseX-px))-" + permutationIndexC[1] + "; i=0; while(i<num) { if(particles[i].age<1) { particles[i].init(dir); break; } i++; } px=mouseX; py=mouseY;} for(int i=0; i<num; i++)  {if(particles[i].age>0) particles[i].update();} void mousePressed() {if(!initialised) { doClear=true; initialised=true; } float time=millis(); if(lastRelease!=-1 && (time-lastRelease)<" + permutationIndexB[1] + ") { doClear=true; for(int i=0; i<num; i++) particles[i].age=0; lastRelease=-1; } else lastRelease=time; } class Particle { Vec2D v,vD; float dir,dirMod,speed; int col,age,stateCnt; Particle() {v=new Vec2D(0,0); vD=new Vec2D(0,0); age=0;} void init(float _dir) {dir=_dir; float prob=random(" + permutationIndexB[4] + "); if(prob<" + permutationIndexB[5] + ") age=" + permutationIndexB[6] + "+int(random(" + permutationIndexB[7] + ")); else if(prob<" + permutationIndexB[8] + ") age=" + permutationIndexB[9] + "+int(random(" + permutationIndexB[10] + ")); else age=" + permutationIndexB[11] + "+int(random(" + permutationIndexB[12] + ")); if(random(" + permutationIndexB[13] + ")<" + permutationIndexB[14] + ") speed=random(" + permutationIndexD[11] + ")+" + permutationIndexD[15] + "; else speed=random(" + permutationIndexD[20] + ")+" + permutationIndexD[18] + "; if(random(" + permutationIndexB[5]+ ")<" + permutationIndexB[11] + ") dirMod=" + permutationIndexC[0] + "; else dirMod=" + permutationIndexC[4] + "; v.set(mouseX,mouseY); initMove(); dir=_dir; stateCnt=" + permutationIndexC[17] + "; if(random(" + permutationIndexB[5] + ")>" + permutationIndexB[4] + ") col=0; else col=1;} void initMove() {if(random(" + permutationIndexB[9] + ")>" + permutationIndexB[11] + ") dirMod=-dirMod; dir+=dirMod; vD.set(speed,0); vD.rotate(radians(dir+" + permutationIndexC[13] + ")); stateCnt=" + permutationIndexD[3] + "+int(random(" + permutationIndexD[11] + ")); if(random( " + permutationIndexC[4] + ")> " + permutationIndexC[11] + ") stateCnt+= " + permutationIndexD[19] + ";} void update() {age--; if(age>=" + permutationIndexD[11] + ") {vD.rotate(radians(" + permutationIndexD[17] + ")); vD.mult(1.01f);} v.add(vD); if(col==0) fill(" + permutationIndexB[3] + "-age,0, " + permutationIndexB[11] + ", " + permutationIndexB[9] + "); else fill(" + permutationIndexB[14] + ", " + permutationIndexB[11] + "-(age/ " + permutationIndexD[11] + "), " + permutationIndexB[13] + "-age, " +  permutationIndexB[17] + "); pushMatrix(); translate(v.x,v.y); rotate(radians(dir)); rect(0,0," + permutationIndexD[3] + ", " + permutationIndexD[13] + "); popMatrix(); if(age==0) { if(random( " + permutationIndexB[11] + ")> " + permutationIndexB[17] + ") fill(" + permutationIndexB[15] + ",0,0, " + permutationIndexB[17] + "); else fill(" + permutationIndexB[15] + ", " + permutationIndexB[17] + ", " + permutationIndexB[11] + ", " + permutationIndexB[15] + "); float size=" + permutationIndexD[3] + "+random(" + permutationIndexD[5] + "); if(random(" + permutationIndexB[11] + ")>" + permutationIndexD[13] + ") size+= " + permutationIndexD[11] + "; ellipse(v.x,v.y,size,size);} if(v.x<0 || v.x>width || v.y<0 || v.y>height) age=0; if(age<30) {stateCnt--; if(stateCnt==0) { initMove(); }} } class Vec2D { float x,y; Vec2D(float _x,float _y) { x=_x; y=_y;} Vec2D(Vec2D v) { x=v.x; y=v.y;} void set(float _x,float _y) { x=_x; y=_y;} void set(Vec2D v) {x=v.x;y=v.y;} void add(float _x,float _y) {x+=_x;y+=_y;} void add(Vec2D v) {x+=v.x;y+=v.y;} void sub(float _x,float _y) {x-=_x;y-=_y;} void sub(Vec2D v) {x-=v.x;y-=v.y;} void mult(float m) {x*=m;y*=m;} void div(float m) {x/=m;y/=m;} float length() {return sqrt(x*x+y*y);} float angle() {return atan2(y,x);} void normalise() {float l=length(); if(l!=0) {x/=l;y/=l;}} Vec2D tangent() {return new Vec2D(-y,x);} void rotate(float val) {double cosval=Math.cos(val); double sinval=Math.sin(val); double tmpx=x*cosval - y*sinval; double tmpy=x*sinval + y*cosval; x=(float)tmpx; y=(float)tmpy;}}"];

let iterationNetwork = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

function hashingProceduralScriptGeneration() {

    for (let i1 = 0; i1 < 10000; i1++) {

        // let metaiterator = 0; if (iterationArray[1] == myValues2.length) { return 0; }
        iterationArray[0] = i1; var iterationArrayIt = i1 % myValues2.length; if (iterationArrayIt == 0) iterationArray[1] += 1;
        range++; let openProcessing = ["openProcessing" + range + ".js"];

        console.log(openProcessing, "utf-8");

        textBlock = ["int num,cnt,px,py; Particle[] particles; boolean initialised=false,doClear=false; float lastRelease=-1; void setup() { size(" + permutationIndexB[0] + ", " + permutationIndexB[1] + "); background(" + permutationIndexB[2] + "); smooth(); rectMode(CENTER_DIAMETER); ellipseMode(CENTER_DIAMETER); cnt=0; num=" + permutationIndexB[3] + "; particles=new Particle[num]; for(int i=0; i<num; i++) particles[i]=new Particle(); px=-1; py=-1;} void draw() { if(doClear) { background(" + permutationIndexB[4] + "); doClear=false; } if(!initialised) { stroke(0); noFill(); pushMatrix(); strokeWeight(" + permutationIndexD[0] + "); translate(width/" + permutationIndexD[1] + "-" + permutationIndexC[0] + ",height/" + permutationIndexD[2] + "-" + permutationIndexD[3] + "); scale(" + permutationIndexD[4] + "," + permutationIndexD[5] + "); beginShape(); vertex(" + permutationIndexD[6] + ",0); vertex(0,0); vertex(0," + permutationIndexD[7] + "); vertex(" + permutationIndexD[8] + "," + permutationIndexD[9] + "); endShape(); beginShape(); vertex(" + permutationIndexD[10] + ",-" + permutationIndexD[11] + "); vertex(" + permutationIndexD[12] + "," + permutationIndexD[13] + "); endShape(); line(" + permutationIndexD[14] + ",-" + permutationIndexD[15] + "," + permutationIndexD[16] + ",-" + permutationIndexD[17] + "); beginShape(); vertex(" + permutationIndexD[18] + ",0); vertex(" + permutationIndexD[19] + ", " + permutationIndexD[0] + "); endShape(); beginShape(); vertex(" + permutationIndexD[1] + ",0); vertex(" + permutationIndexD[2] + ",0); vertex(" + permutationIndexD[3] + ", " + permutationIndexD[4] + "); vertex(" + + permutationIndexD[4] + + ", " + permutationIndexD[5] + "); endShape(); line(" + permutationIndexD[6] + ", " + permutationIndexD[7] + ", "  + permutationIndexD[8] +  ", " + + permutationIndexD[9] + + "); line(" + + permutationIndexD[10] + + "," + + permutationIndexD[11] + ", " + permutationIndexD[12] + ", " + permutationIndexD[13] + "); line(" + permutationIndexD[12] + ", " + permutationIndexD[13] + ", " + permutationIndexD[14] + " ,-" + permutationIndexD[15] + "); line(" + permutationIndexD[15] + ", + " + permutationIndexD[16] + ", " + permutationIndexD[17] + ", " + permutationIndexD[18] + "); popMatrix();} noStroke(); if(mousePressed) { int partNum,i; float dir; if(px==-1) { px=mouseX; py=mouseY; dir=0;} else if(px==mouseX && py==mouseY) dir=int(random(" + permutationIndexD[0] + "))*" + permutationIndexD[1] + "; else dir=degrees(atan2(mouseY-py,mouseX-px))-" + permutationIndexC[1] + "; i=0; while(i<num) { if(particles[i].age<1) { particles[i].init(dir); break; } i++; } px=mouseX; py=mouseY;} for(int i=0; i<num; i++)  {if(particles[i].age>0) particles[i].update();} void mousePressed() {if(!initialised) { doClear=true; initialised=true; } float time=millis(); if(lastRelease!=-1 && (time-lastRelease)<" + permutationIndexB[1] + ") { doClear=true; for(int i=0; i<num; i++) particles[i].age=0; lastRelease=-1; } else lastRelease=time; } class Particle { Vec2D v,vD; float dir,dirMod,speed; int col,age,stateCnt; Particle() {v=new Vec2D(0,0); vD=new Vec2D(0,0); age=0;} void init(float _dir) {dir=_dir; float prob=random(" + permutationIndexB[4] + "); if(prob<" + permutationIndexB[5] + ") age=" + permutationIndexB[6] + "+int(random(" + permutationIndexB[7] + ")); else if(prob<" + permutationIndexB[8] + ") age=" + permutationIndexB[9] + "+int(random(" + permutationIndexB[10] + ")); else age=" + permutationIndexB[11] + "+int(random(" + permutationIndexB[12] + ")); if(random(" + permutationIndexB[13] + ")<" + permutationIndexB[14] + ") speed=random(" + permutationIndexD[11] + ")+" + permutationIndexD[15] + "; else speed=random(" + permutationIndexD[20] + ")+" + permutationIndexD[18] + "; if(random(" + permutationIndexB[5]+ ")<" + permutationIndexB[11] + ") dirMod=" + permutationIndexC[0] + "; else dirMod=" + permutationIndexC[4] + "; v.set(mouseX,mouseY); initMove(); dir=_dir; stateCnt=" + permutationIndexC[17] + "; if(random(" + permutationIndexB[5] + ")>" + permutationIndexB[4] + ") col=0; else col=1;} void initMove() {if(random(" + permutationIndexB[9] + ")>" + permutationIndexB[11] + ") dirMod=-dirMod; dir+=dirMod; vD.set(speed,0); vD.rotate(radians(dir+" + permutationIndexC[13] + ")); stateCnt=" + permutationIndexD[3] + "+int(random(" + permutationIndexD[11] + ")); if(random( " + permutationIndexC[4] + ")> " + permutationIndexC[11] + ") stateCnt+= " + permutationIndexD[19] + ";} void update() {age--; if(age>=" + permutationIndexD[11] + ") {vD.rotate(radians(" + permutationIndexD[17] + ")); vD.mult(1.01f);} v.add(vD); if(col==0) fill(" + permutationIndexB[3] + "-age,0, " + permutationIndexB[11] + ", " + permutationIndexB[9] + "); else fill(" + permutationIndexB[14] + ", " + permutationIndexB[11] + "-(age/ " + permutationIndexD[11] + "), " + permutationIndexB[13] + "-age, " +  permutationIndexB[17] + "); pushMatrix(); translate(v.x,v.y); rotate(radians(dir)); rect(0,0," + permutationIndexD[3] + ", " + permutationIndexD[13] + "); popMatrix(); if(age==0) { if(random( " + permutationIndexB[11] + ")> " + permutationIndexB[17] + ") fill(" + permutationIndexB[15] + ",0,0, " + permutationIndexB[17] + "); else fill(" + permutationIndexB[15] + ", " + permutationIndexB[17] + ", " + permutationIndexB[11] + ", " + permutationIndexB[15] + "); float size=" + permutationIndexD[3] + "+random(" + permutationIndexD[5] + "); if(random(" + permutationIndexB[11] + ")>" + permutationIndexD[13] + ") size+= " + permutationIndexD[11] + "; ellipse(v.x,v.y,size,size);} if(v.x<0 || v.x>width || v.y<0 || v.y>height) age=0; if(age<30) {stateCnt--; if(stateCnt==0) { initMove(); }} } class Vec2D { float x,y; Vec2D(float _x,float _y) { x=_x; y=_y;} Vec2D(Vec2D v) { x=v.x; y=v.y;} void set(float _x,float _y) { x=_x; y=_y;} void set(Vec2D v) {x=v.x;y=v.y;} void add(float _x,float _y) {x+=_x;y+=_y;} void add(Vec2D v) {x+=v.x;y+=v.y;} void sub(float _x,float _y) {x-=_x;y-=_y;} void sub(Vec2D v) {x-=v.x;y-=v.y;} void mult(float m) {x*=m;y*=m;} void div(float m) {x/=m;y/=m;} float length() {return sqrt(x*x+y*y);} float angle() {return atan2(y,x);} void normalise() {float l=length(); if(l!=0) {x/=l;y/=l;}} Vec2D tangent() {return new Vec2D(-y,x);} void rotate(float val) {double cosval=Math.cos(val); double sinval=Math.sin(val); double tmpx=x*cosval - y*sinval; double tmpy=x*sinval + y*cosval; x=(float)tmpx; y=(float)tmpy;}}"];
        console.log(permutationIndexA[0], permutationIndexA[1], permutationIndexA[2], permutationIndexA[3]);

        fs.writeFileSync("./openProcessing/" + openProcessing, textBlock);

        for(let a1=0; a1<12; a1++) {
            iterationNetwork[a1]=Math.floor((Math.random()*a1)+1); 
            permutationIndexA[a1] = resolution[iterationNetwork[a1]] % resolution.length;
            permutationIndexB[a1] = colors[iterationNetwork[a1]] % colors.length;
            permutationIndexC[a1] = midRangeSmallNumbers[iterationNetwork[a1]] % midRangeSmallNumbers.length;
            permutationIndexD[a1] = smallNumbers[iterationNetwork[a1]] % smallNumbers.length;
            // console.log(permutationIndexA[a1], permutationIndexB[a1]);
        }

        /*
            {
                var sourceSignal1, sourceSignal2, ampModulationSignal1, ampModulationSignal2; 
                ampModulationSignal1 = SinOsc.kr(SinOsc.kr(0.333*3.14)); 
                ampModulationSignal2 = SinOsc.kr(SinOsc.kr(0.505*3.14)); 
                sourceSignal1 = Saw.ar(30*0.5*3.14, mul: SinOsc.kr(ampModulationSignal1)); 
                sourceSignal2 = Saw.ar(31*0.5*3.14*3.33, mul: SinOsc.kr(ampModulationSignal2));
                Pan2.ar(sourceSignal1+sourceSignal2, 0, 1);
            }.scope;
        */

    }

    return 0;

}

hashingProceduralScriptGeneration();